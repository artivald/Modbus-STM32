package org;

import java.net.*;
import java.nio.channels.DatagramChannel;
import javax.swing.Timer;
import javax.swing.*;
import java.awt.event.*;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.io.FileInputStream;
import java.io.ByteArrayOutputStream;
import java.util.Arrays;
import java.io.File;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.swt.widgets.FileDialog;
import java.awt.Cursor;
import java.nio.charset.StandardCharsets;
import org.eclipse.swt.SWT;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.FileDialog;
import org.eclipse.swt.widgets.Shell;

/**
 *
 * @author Сергей
 */
public class MainForm extends javax.swing.JFrame {

    
    private DatagramChannel udpChannel;
    private Timer tim10ms;
    private ByteBuffer receiveBuffer;
    private int timeoutOut = 0;
    private String selectedFilePath;
    private final int PACKET_SIZE = 32; // Размер пакета
    private boolean isSending = true; // Флаг для определения, выполняется ли отправка данных
    public String ip = "192.168.66.191"; // IP-адрес для подключения
    public int port = 502; // Порт для подключения
    private File file; // Файл для передачи
    private FileInputStream fileInputStream; // Поток чтения файла
    private ByteArrayOutputStream outputStream; // Буфер для сбора пакетов данных
    private long totalBytesRead = 0; // Объявление и инициализация переменной totalBytesRead
    private long totalFileSize = 0; // Объявление и инициализация переменной totalFileSize
    boolean errorMessageDisplayed = false; // Флаг для отслеживания вывода сообщения об ошибке
    public int ModbusAdres = 0;
    public int NomPos = 0;
    public int Col_Byte;
    
    /**
     * Creates new form MainForm
     */
    
    
    
    public MainForm() {
        initComponents(); {
    // ... existing code ...

        tim10ms = new Timer(10, (e) -> {
            Every10ms();   
            });
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    
    @SuppressWarnings("unchecked") 
    
    
    
    private void processReceivedData(byte[] data) {
    // Обработка полученных данных
    // Ваш код здесь
    // Например, вы можете вывести данные в консоль или обновить соответствующие элементы интерфейса

    StringBuilder sb = new StringBuilder();
    for (byte b : data) {
        sb.append(String.format("%02X ", b));
    }    
    System.out.println("Полученные данные: " + sb.toString());
    
    
    // Или
    // someLabel.setText("Полученные данные: " + sb.toString());
}

    
    
    
       private boolean isLastResponse(byte[] data) {
    // Проверка условия, при котором текущий ответ считается последним
    // Верните true, если это последний ответ, и false в противном случае
    // Например, если ответ содержит определенный флаг или имеет специальный формат
    // Верните true, если ваша проверка успешна
    // В примере ниже всегда возвращается false, что означает, что текущий ответ не является последним
    return false;
}   
ActionListener button3Listener = new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        String ip = jTextField1.getText();
        int port = Integer.parseInt(jTextField2.getText());

        try {
            // Создание буфера запроса размером 12 байт (заголовок + адреса регистров)
            ByteBuffer buffer = ByteBuffer.allocate(12);

            // Запись заголовка сообщения
            buffer.putShort((short) 0x000F); // Идентификатор транзакции
            buffer.putShort((short) 0x0000); // Идентификатор протокола
            buffer.putShort((short) 0x0006); // Длина сообщения
            buffer.put((byte) 0xF7); // Modbus адрес устройства
            buffer.put((byte) 0x03); // Функция Modbus - чтение Holding Registers
            buffer.putShort((short) 15);
            buffer.putShort((short) 2);

            buffer.flip(); // Подготовка буфера к чтению

            // Отправка запроса
            udpChannel.send(ByteBuffer.wrap(buffer.array()), new InetSocketAddress(ip, port));
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    }
};

private void Flag(){
errorMessageDisplayed = false;
}


private void Every10ms1() {
  try {
        System.out.println(ip);
        // Создание буфера запроса размером 13 байт (заголовок + адреса регистров + Modbus-адрес)
        ByteBuffer buffer = ByteBuffer.allocate(13);

        // Запись заголовка сообщения
        buffer.putShort((short) 0x000F); // Идентификатор транзакции
        buffer.putShort((short) 0x0000); // Идентификатор протокола
        buffer.putShort((short) 0x0006); // Длина сообщения
        
        // Запись Modbus-адреса
        buffer.put((byte) ModbusAdres); // Modbus адрес устройства

        buffer.put((byte) 0x04); // Функция Modbus - чтение Holding Registers
        buffer.putShort((short) 17);
        buffer.putShort((short) 2);

        buffer.flip(); // Подготовка буфера к чтению

        // Отправка запроса
        udpChannel.send(ByteBuffer.wrap(buffer.array()), new InetSocketAddress(ip, port));

        // Задержка на 500 миллисекунд
        Thread.sleep(500);

        // Получение ответа
        byte[] inBuf = new byte[512];
        ByteBuffer receiveBuffer = ByteBuffer.wrap(inBuf);
        SocketAddress deviceAddress = udpChannel.receive(receiveBuffer);

        if (deviceAddress != null) {
            byte[] data = new byte[receiveBuffer.position()];
            receiveBuffer.flip();
            receiveBuffer.get(data);

            // Вывод данных в поле jTextPane1
            StringBuilder sb = new StringBuilder();
            for (byte b : data) {
                sb.append(String.format("%02X ", b));
            }

            // Извлечение значений из 15-й и 16-й ячеек памяти
            int value1 = data[9] & 0xFF;
            int value2 = data[10] & 0xFF;
            int value3 = data[11] & 0xFF;
            int value4 = data[12] & 0xFF;

            // вер маж 9, минор 10
            // дата год 11, мес 12

            String formattedValue15 = String.format("%d.%02d", value1, value2);

            // Преобразование value16 в формат "07.2023"
            String formattedValue16 = String.format("%02d.%04d", value4, value3 + 2000);

            String memoryValues = "Версия прошивки: " + formattedValue15 + "\nДата прошивки: " + formattedValue16;
            // Установка полученных данных в поле jTextPane1
            SwingUtilities.invokeLater(() -> {
                jTextPane1.setText(memoryValues);
            });
        } else {
            // Ошибка - устройство не ответило
            if (!errorMessageDisplayed) { // Проверка флага для избежания повторного вывода сообщения
                JOptionPane.showMessageDialog(this, "Ошибка - устройство не ответило", "Ошибка", JOptionPane.ERROR_MESSAGE);
            }
        }
    } catch (IOException ex) {
        ex.printStackTrace();
    } catch (InterruptedException ex) {
        ex.printStackTrace();
    }
 
}

private void Every10ms() {    
try {
  byte[] inBuf = new byte[512];
receiveBuffer = ByteBuffer.wrap(inBuf);
SocketAddress deviceAddress = udpChannel.receive(receiveBuffer);

if (isSending) {
    // Выполнять отправку данных
    if (fileInputStream == null) {
        if (selectedFilePath == null) {
            JOptionPane.showMessageDialog(this, "Файл не выбран.", "Ошибка", JOptionPane.ERROR_MESSAGE);
            isSending = false;
            return;
        }

        file = new File(selectedFilePath);
        fileInputStream = new FileInputStream(file);
        outputStream = new ByteArrayOutputStream();
        totalFileSize = file.length(); // Установка размера файла
    }

    byte[] chunk = new byte[PACKET_SIZE];
    int bytesRead = fileInputStream.read(chunk);
    int Col_Reg=0;
    Col_Byte=0;
    if (bytesRead != -1) {        
        Col_Reg = (bytesRead/2)+(bytesRead%2);
        if (bytesRead%2==1)
        {Col_Byte=(bytesRead+1);} // количество байт далее, если в посылке не чётно колво байт допишется ещё один сзади байт (0) сзади
        else
        {Col_Byte=bytesRead;}
        ByteBuffer buffer = ByteBuffer.allocate(13 + 2 + 2 + Col_Byte);
        buffer.putShort((short) 0x0000); // Идентификатор транзакции
        buffer.putShort((short) 0x0000); // Идентификатор протокола
        buffer.putShort((short) (13 + 2 + 2 + Col_Byte)); // Длина сообщения
        buffer.put((byte) ModbusAdres); // Modbus адрес устройства
        buffer.put((byte) 0x10); // Фуеенкция Modbus - запись нескольких Holding Registers
        buffer.putShort((short) 0x1D00); // Адрес первого регистра Hi and Lo           
        buffer.putShort((short) Col_Reg); // Количество регистров
        buffer.put((byte) (Col_Byte+4)); //количество байт далее
        buffer.putShort((short) NomPos); // интедификатор блока (номер)
        buffer.putShort((short) (bytesRead)); // (размер того что идёт после номера блока
        
     
        
        
        if (bytesRead%2==1)
        {buffer.put(chunk, 0, bytesRead);
        buffer.put((byte) 0x0000);
        buffer.flip();} // количество байт далее, если в посылке не чётно колво байт допишется ещё один сзади байт (0) сзади
        else
        {buffer.put(chunk, 0, bytesRead);
        buffer.flip();}
        
        

        byte[] bufferData = new byte[buffer.remaining()];
        buffer.get(bufferData);
        outputStream.write(bufferData);

        // Отправка пакета
        try {
            udpChannel.send(ByteBuffer.wrap(bufferData), new InetSocketAddress(ip, port));

            // Вывод отправленных данных
            System.out.println("Отправленные данные:");
             for (byte b : bufferData) {
                 System.err.println(Col_Byte);
                System.out.print(String.format("%02X ", b));
            
            }
            System.out.println();

        } catch (IOException ex) {
            JOptionPane.showMessageDialog(this, "Ошибка при отправке данных", "Ошибка", JOptionPane.ERROR_MESSAGE);
            ex.printStackTrace();
            isSending = false;
            return;
        }
    


            // Обновление прогресс-бара
            totalBytesRead += bytesRead;
            int progress = (int) ((totalBytesRead * 100) / totalFileSize);
            jProgressBar1.setValue(progress);

            // Переключение на чтение данных
            isSending = false;
        } else { // Если файл кончился
            // Завершение передачи файла
            byte[] data = outputStream.toByteArray();
            try {
                udpChannel.send(ByteBuffer.wrap(data), new InetSocketAddress(ip, port));
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(this, "Ошибка при отправке данных", "Ошибка", JOptionPane.ERROR_MESSAGE);
                ex.printStackTrace();
                isSending = false;
                return;
            }

            fileInputStream.close();
            fileInputStream = null;
            outputStream.close();
            outputStream = null;

            // Переключение на чтение данных
            isSending = false;

            // Проверка завершения передачи файла
            if (totalBytesRead >= totalFileSize) {
               
                // Вывод окна с сообщением
                timeoutOut += 0;
                timeoutOut += 10;
                ByteBuffer buffer = ByteBuffer.allocate(13 + 2 + 2 + 2);
                buffer.putShort((short) 0x0000); // Идентификатор транзакции
                buffer.putShort((short) 0x0000); // Идентификатор протокола
                buffer.putShort((short) (13 + 2 + 2 + 2)); // Длина сообщения
                buffer.put((byte) ModbusAdres); // Modbus адрес устройства
                buffer.put((byte) 0x10); // Функция Modbus - запись нескольких Holding Registers
                buffer.putShort((short) 0x1D13); // Адрес регистра 0x1D13
                buffer.putShort((short) 0x0001); // Количество регистров для записи
                buffer.putShort((short) totalFileSize); // Значение для записи
                
                buffer.flip();
                byte[] bufferData = new byte[buffer.remaining()];
                buffer.get(bufferData);
               
                
                try {
                udpChannel.send(ByteBuffer.wrap(bufferData), new InetSocketAddress(ip, port));
                JOptionPane.showMessageDialog(this, "Прошивка отправлена", "Успех", JOptionPane.INFORMATION_MESSAGE);
                 if (timeoutOut > 1000) {
                JOptionPane.showMessageDialog(this, "Ошибка подключения", "Ошибка", JOptionPane.ERROR_MESSAGE);
                timeoutOut = 0;
                btnDownload.setEnabled(true);
                btnChooseFile.setEnabled(true);
                btnGetInfo.setEnabled(true);
                tim10ms.stop(); // Остановить таймер
                udpChannel.close(); // Закрыть соединение
                 }
                } catch (IOException ex) {
                JOptionPane.showMessageDialog(this, "Ошибка при записи размера прошивки", "Ошибка", JOptionPane.ERROR_MESSAGE);
                ex.printStackTrace();
                return;    }
                
                
                
                udpChannel.close(); // Закрыть соединение после передачи последнего набора байт
                tim10ms.stop(); // Остановить таймер
                // Сброс прогресс-бара
                jProgressBar1.setValue(0);

                // Разблокировка кнопок
                btnDownload.setEnabled(true);
                btnChooseFile.setEnabled(true);
                btnGetInfo.setEnabled(true);

                return;
            }
        }
    } else {
        // Выполнять чтение данных
        if (deviceAddress != null) {
            byte[] data = new byte[receiveBuffer.position()];
            receiveBuffer.flip();
            receiveBuffer.get(data);
            NomPos++;
            processReceivedData(data);
            timeoutOut = 0;

            // Проверка, является ли текущий ответ последним
            if (isLastResponse(data)) {
                btnDownload.setEnabled(true);
                btnChooseFile.setEnabled(true);
                btnGetInfo.setEnabled(true);
                udpChannel.close(); // Закрыть соединение после прочтения последнего ответа
                tim10ms.stop(); // Остановить таймер
            }

            // Переключение на отправку данных
            isSending = true;
        } else {
            timeoutOut += 10;
            if (timeoutOut > 1000) {
                JOptionPane.showMessageDialog(this, "Ошибка подключения", "Ошибка", JOptionPane.ERROR_MESSAGE);
                timeoutOut = 0;
                btnDownload.setEnabled(true);
                btnChooseFile.setEnabled(true);
                btnGetInfo.setEnabled(true);
                tim10ms.stop(); // Остановить таймер
                udpChannel.close(); // Закрыть соединение
            }
        }
    }
} catch (IOException ex) {
    btnDownload.setEnabled(true);
    btnChooseFile.setEnabled(true);
    btnGetInfo.setEnabled(true);
    tim10ms.stop(); // Остановить таймер

    ex.printStackTrace();}}

    
     

        
   
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTextField1 = new javax.swing.JTextField();
        btnDownload = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        jTextField2 = new javax.swing.JTextField();
        btnChooseFile = new javax.swing.JButton();
        jProgressBar1 = new javax.swing.JProgressBar();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextPane1 = new javax.swing.JTextPane();
        btnGetInfo = new javax.swing.JButton();
        jTextField3 = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jTextField1.setText("192.168.1.55");
        jTextField1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField1ActionPerformed(evt);
            }
        });

        btnDownload.setText("Прошить");
        btnDownload.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnDownloadActionPerformed(evt);
            }
        });

        jLabel2.setText("Введите ip  адрес");

        jLabel1.setText("Введите порт соединения");

        jTextField2.setText("502");
        jTextField2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField2ActionPerformed(evt);
            }
        });

        btnChooseFile.setText("Выбрать прошивку");
        btnChooseFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnChooseFileActionPerformed(evt);
            }
        });

        jProgressBar1.setForeground(new java.awt.Color(51, 51, 255));
        jProgressBar1.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));

        jLabel3.setText("Прогресс");

        jLabel4.setText("Текущая версия пошивки");

        jScrollPane1.setViewportView(jTextPane1);

        btnGetInfo.setText("Инфо");
        btnGetInfo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnGetInfoActionPerformed(evt);
            }
        });

        jTextField3.setText("1");
        jTextField3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField3ActionPerformed(evt);
            }
        });

        jLabel5.setText("Modbus адрес");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(36, 36, 36)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addGap(47, 47, 47)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(btnGetInfo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btnChooseFile, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(btnDownload, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jProgressBar1, javax.swing.GroupLayout.DEFAULT_SIZE, 160, Short.MAX_VALUE))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(jLabel2)
                            .addComponent(jLabel4)
                            .addComponent(jLabel5))
                        .addGap(47, 47, 47)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jTextField1, javax.swing.GroupLayout.DEFAULT_SIZE, 196, Short.MAX_VALUE)
                            .addComponent(jTextField2)
                            .addComponent(jScrollPane1)
                            .addComponent(jTextField3))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(17, 17, 17)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addGap(17, 17, 17)
                        .addComponent(jLabel1))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addComponent(jLabel5)
                        .addGap(18, 18, 18)
                        .addComponent(jLabel4)
                        .addGap(29, 29, 29))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 45, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)))
                .addComponent(btnGetInfo)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(btnChooseFile)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(btnDownload)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jProgressBar1, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel3))
                .addContainerGap(80, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
      
// меня интересует только это
    private void btnDownloadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnDownloadActionPerformed
   NomPos = 0; 
    try {
            udpChannel = DatagramChannel.open();
            udpChannel.configureBlocking(false);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    ip = jTextField1.getText();
    port = Integer.parseInt(jTextField2.getText()); 
    ModbusAdres  = Integer.parseInt(jTextField3.getText());
        try {
        InetAddress.getByName(ip);
        if (port < 0 || port > 65535) {
            JOptionPane.showMessageDialog(this, "Неверный порт.", "Ошибка", JOptionPane.ERROR_MESSAGE);
            return;
        }
    } catch (UnknownHostException ex) {
        JOptionPane.showMessageDialog(this, "Неверный IP-адрес.", "Ошибка", JOptionPane.ERROR_MESSAGE);
        return;
    }

    if (selectedFilePath == null) {
        JOptionPane.showMessageDialog(this, "Файл не выбран.", "Ошибка", JOptionPane.ERROR_MESSAGE);
        return;
    }

    File selectedFile = new File(selectedFilePath);
    long fileSize = selectedFile.length();
    if (fileSize > 28672) {
        JOptionPane.showMessageDialog(this, "Размер файла превышает максимальный предел.", "Ошибка", JOptionPane.ERROR_MESSAGE);
        return;
    }

    totalBytesRead = 0;
    totalFileSize = fileSize;

    isSending = true;

    tim10ms.start();

    btnDownload.setEnabled(false);
    btnChooseFile.setEnabled(false);
    btnGetInfo.setEnabled(false);
    }//GEN-LAST:event_btnDownloadActionPerformed


    private void jTextField2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextField2ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextField2ActionPerformed

    private void jTextField1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextField1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextField1ActionPerformed

    private void btnChooseFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnChooseFileActionPerformed
     Display display = Display.getDefault();
    Shell shell = new Shell(display);

    FileDialog fileDialog = new FileDialog(shell, SWT.OPEN);
    String[] filterExtensions = new String[]{"*.*"};
    fileDialog.setFilterExtensions(filterExtensions);

    this.selectedFilePath = fileDialog.open();

    if (this.selectedFilePath != null) {
        System.out.println("Выбранный файл: " + this.selectedFilePath);

        // Проверка размера файла
        File selectedFile = new File(this.selectedFilePath);
        long fileSize = selectedFile.length();
        if (fileSize > 28672) {
            JOptionPane.showMessageDialog(this, "Размер файла превышает максимальный предел.", "Ошибка", JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Дополнительный код для обработки выбранного файла
        // ...
    } else {
        System.out.println("Файл не выбран.");
    }

    shell.dispose();
    display.dispose();
    }//GEN-LAST:event_btnChooseFileActionPerformed

    private void btnGetInfoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnGetInfoActionPerformed
    
    try {
            udpChannel = DatagramChannel.open();
            udpChannel.configureBlocking(false);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
    ip = jTextField1.getText();
    port = Integer.parseInt(jTextField2.getText()); 
    ModbusAdres  = Integer.parseInt(jTextField3.getText()); 
    Every10ms1();
    
    }//GEN-LAST:event_btnGetInfoActionPerformed

    private void jTextField3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextField3ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextField3ActionPerformed
    

    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MainForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MainForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MainForm().setVisible(true);
            } });
    }
    
    
//System.exit(0); аварийный  

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnChooseFile;
    private javax.swing.JButton btnDownload;
    private javax.swing.JButton btnGetInfo;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JProgressBar jProgressBar1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField2;
    private javax.swing.JTextField jTextField3;
    private javax.swing.JTextPane jTextPane1;
    // End of variables declaration//GEN-END:variables
}
